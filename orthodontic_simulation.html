<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Simulation - Cylinder with Forces</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .info {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        canvas {
            border: 2px solid #333;
            background-color: #fff;
            cursor: crosshair;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        button:hover {
            background-color: #45a049;
        }

        button:active {
            transform: translateY(1px);
        }

        button.delete-mode {
            background-color: #f44336;
        }

        button.delete-mode:hover {
            background-color: #da190b;
        }

        .instructions {
            max-width: 800px;
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 5px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <h1>Physics Simulation - Cylinder with Forces</h1>

    <div class="info">
        <strong>Principle:</strong> The cylinder moves and rotates freely based on applied forces.
    </div>

    <canvas id="simulationCanvas" width="800" height="600"></canvas>

    <div class="controls">
        <button id="addForceBtn">Add Force</button>
        <button id="deleteForceBtn">Delete Force</button>
        <button id="resetBtn">Reset</button>
    </div>

    <div class="instructions">
        <strong>Instructions:</strong><br>
        • Click "Add Force" then click on canvas to place a new force vector<br>
        • Drag arrow heads to change force direction and magnitude<br>
        • Drag arrow tails to reposition forces<br>
        • Click "Delete Force" then click on a force to remove it<br>
        • The cylinder moves and rotates freely based on all applied forces<br>
        • Drag forces to see continuous motion
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const addForceBtn = document.getElementById('addForceBtn');
        const deleteForceBtn = document.getElementById('deleteForceBtn');
        const resetBtn = document.getElementById('resetBtn');

        const GRID_SIZE = 50;
        const CYLINDER_RADIUS = 40;

        // Cylinder properties
        let cylinder = {
            x: 400,
            y: 300,
            vx: 0,
            vy: 0,
            rotation: 0,
            angularVelocity: 0,
            mass: 10,
            momentOfInertia: 0.5 * 10 * CYLINDER_RADIUS * CYLINDER_RADIUS
        };

        // Forces array
        let forces = [];

        // Interaction state
        let dragging = null;
        let dragType = null;
        let isDragging = false;
        let addForceMode = false;
        let deleteForceMode = false;

        // Colors for forces
        const forceColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];

        // Reset function
        function reset() {
            cylinder = {
                x: 400,
                y: 300,
                vx: 0,
                vy: 0,
                rotation: 0,
                angularVelocity: 0,
                mass: 10,
                momentOfInertia: 0.5 * 10 * CYLINDER_RADIUS * CYLINDER_RADIUS
            };
            forces = [];
            addForceMode = false;
            deleteForceMode = false;
            addForceBtn.style.backgroundColor = '#4CAF50';
            deleteForceBtn.style.backgroundColor = '#4CAF50';
        }

        resetBtn.addEventListener('click', reset);

        addForceBtn.addEventListener('click', () => {
            addForceMode = !addForceMode;
            deleteForceMode = false;
            addForceBtn.style.backgroundColor = addForceMode ? '#ff9800' : '#4CAF50';
            deleteForceBtn.style.backgroundColor = '#4CAF50';
            canvas.style.cursor = addForceMode ? 'crosshair' : 'move';
        });

        deleteForceBtn.addEventListener('click', () => {
            deleteForceMode = !deleteForceMode;
            addForceMode = false;
            deleteForceBtn.style.backgroundColor = deleteForceMode ? '#f44336' : '#4CAF50';
            addForceBtn.style.backgroundColor = '#4CAF50';
            canvas.style.cursor = deleteForceMode ? 'pointer' : 'move';
        });

        // Draw grid
        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Draw cylinder
        function drawCylinder() {
            ctx.save();
            ctx.translate(cylinder.x, cylinder.y);
            ctx.rotate(cylinder.rotation);

            // Cylinder body
            ctx.fillStyle = '#95a5a6';
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, CYLINDER_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Reference line to show rotation
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(CYLINDER_RADIUS, 0);
            ctx.stroke();

            ctx.restore();

            // Draw center of mass
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(cylinder.x, cylinder.y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.fillText('CM', cylinder.x + 8, cylinder.y - 8);
        }

        // Draw arrow
        function drawArrow(force, color, index) {
            const endX = force.x + Math.cos(force.angle) * force.magnitude;
            const endY = force.y + Math.sin(force.angle) * force.magnitude;

            // Arrow shaft
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(force.x, force.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Arrow head
            const headLength = 15;
            const headAngle = Math.PI / 6;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headLength * Math.cos(force.angle - headAngle),
                endY - headLength * Math.sin(force.angle - headAngle)
            );
            ctx.lineTo(
                endX - headLength * Math.cos(force.angle + headAngle),
                endY - headLength * Math.sin(force.angle + headAngle)
            );
            ctx.closePath();
            ctx.fill();

            // Draw tail point
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(force.x, force.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Label
            ctx.fillStyle = color;
            ctx.font = 'bold 12px Arial';
            ctx.fillText(`F${index + 1}`, force.x - 20, force.y - 10);
        }

        // Draw moment arm
        function drawMomentArm(force, color) {
            const forceEndX = force.x + Math.cos(force.angle) * 1000;
            const forceEndY = force.y + Math.sin(force.angle) * 1000;

            const dx = forceEndX - force.x;
            const dy = forceEndY - force.y;
            const t = ((cylinder.x - force.x) * dx + (cylinder.y - force.y) * dy) / (dx * dx + dy * dy);
            const closestX = force.x + t * dx;
            const closestY = force.y + t * dy;

            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(cylinder.x, cylinder.y);
            ctx.lineTo(closestX, closestY);
            ctx.stroke();
            ctx.setLineDash([]);

            const distance = Math.sqrt((cylinder.x - closestX) ** 2 + (cylinder.y - closestY) ** 2);
            return distance;
        }

        // Calculate net force and torque
        function calculatePhysics() {
            let netForceX = 0;
            let netForceY = 0;
            let netTorque = 0;

            forces.forEach(force => {
                const fx = Math.cos(force.angle) * force.magnitude;
                const fy = Math.sin(force.angle) * force.magnitude;

                netForceX += fx;
                netForceY += fy;

                // Torque = r × F (cross product)
                const rx = force.x - cylinder.x;
                const ry = force.y - cylinder.y;
                const torque = rx * fy - ry * fx;
                netTorque += torque;
            });

            return { netForceX, netForceY, netTorque };
        }

        // Update physics
        function updatePhysics(dt) {
            if (isDragging) {
                const { netForceX, netForceY, netTorque } = calculatePhysics();

                // Linear acceleration
                const ax = netForceX / cylinder.mass;
                const ay = netForceY / cylinder.mass;

                // Update velocity
                cylinder.vx += ax * dt * 0.1;
                cylinder.vy += ay * dt * 0.1;

                // Update position
                cylinder.x += cylinder.vx * dt;
                cylinder.y += cylinder.vy * dt;

                // Angular acceleration
                const angularAccel = netTorque / cylinder.momentOfInertia;
                cylinder.angularVelocity += angularAccel * dt * 0.0001;

                // Update rotation
                cylinder.rotation += cylinder.angularVelocity * dt;

                // Boundary check
                if (cylinder.x < CYLINDER_RADIUS) {
                    cylinder.x = CYLINDER_RADIUS;
                    cylinder.vx = 0;
                }
                if (cylinder.x > canvas.width - CYLINDER_RADIUS) {
                    cylinder.x = canvas.width - CYLINDER_RADIUS;
                    cylinder.vx = 0;
                }
                if (cylinder.y < CYLINDER_RADIUS) {
                    cylinder.y = CYLINDER_RADIUS;
                    cylinder.vy = 0;
                }
                if (cylinder.y > canvas.height - CYLINDER_RADIUS) {
                    cylinder.y = canvas.height - CYLINDER_RADIUS;
                    cylinder.vy = 0;
                }
            } else {
                // Apply damping when not dragging
                cylinder.vx *= 0.95;
                cylinder.vy *= 0.95;
                cylinder.angularVelocity *= 0.95;

                cylinder.x += cylinder.vx * dt;
                cylinder.y += cylinder.vy * dt;
                cylinder.rotation += cylinder.angularVelocity * dt;
            }
        }

        // Update and render
        let lastTime = performance.now();
        function animate(currentTime) {
            const dt = currentTime - lastTime;
            lastTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            drawGrid();

            // Update physics
            updatePhysics(dt);

            // Draw moment arms
            forces.forEach((force, i) => {
                const color = forceColors[i % forceColors.length];
                drawMomentArm(force, color);
            });

            // Draw forces
            forces.forEach((force, i) => {
                const color = forceColors[i % forceColors.length];
                drawArrow(force, color, i);
            });

            // Draw cylinder
            drawCylinder();

            // Display info
            const { netForceX, netForceY, netTorque } = calculatePhysics();
            ctx.fillStyle = 'black';
            ctx.font = '14px Arial';
            ctx.fillText(`Forces: ${forces.length}`, 10, 20);
            ctx.fillText(`Net Force: (${netForceX.toFixed(1)}, ${netForceY.toFixed(1)})`, 10, 40);
            ctx.fillText(`Net Torque: ${netTorque.toFixed(1)}`, 10, 60);
            ctx.fillText(`Position: (${cylinder.x.toFixed(0)}, ${cylinder.y.toFixed(0)})`, 10, 80);
            ctx.fillText(`Rotation: ${(cylinder.rotation * 180 / Math.PI).toFixed(1)}°`, 10, 100);

            requestAnimationFrame(animate);
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (addForceMode) {
                forces.push({
                    x: mouseX,
                    y: mouseY,
                    magnitude: 60,
                    angle: 0
                });
                addForceMode = false;
                addForceBtn.style.backgroundColor = '#4CAF50';
                canvas.style.cursor = 'move';
                return;
            }

            if (deleteForceMode) {
                for (let i = forces.length - 1; i >= 0; i--) {
                    const force = forces[i];
                    const endX = force.x + Math.cos(force.angle) * force.magnitude;
                    const endY = force.y + Math.sin(force.angle) * force.magnitude;

                    const distToHead = Math.sqrt((mouseX - endX) ** 2 + (mouseY - endY) ** 2);
                    const distToTail = Math.sqrt((mouseX - force.x) ** 2 + (mouseY - force.y) ** 2);

                    if (distToHead < 15 || distToTail < 10) {
                        forces.splice(i, 1);
                        break;
                    }
                }
                deleteForceMode = false;
                deleteForceBtn.style.backgroundColor = '#4CAF50';
                canvas.style.cursor = 'move';
                return;
            }

            // Check for dragging forces
            for (let i = forces.length - 1; i >= 0; i--) {
                const force = forces[i];
                const endX = force.x + Math.cos(force.angle) * force.magnitude;
                const endY = force.y + Math.sin(force.angle) * force.magnitude;

                if (Math.sqrt((mouseX - endX) ** 2 + (mouseY - endY) ** 2) < 15) {
                    dragging = force;
                    dragType = 'head';
                    isDragging = true;
                    return;
                }

                if (Math.sqrt((mouseX - force.x) ** 2 + (mouseY - force.y) ** 2) < 10) {
                    dragging = force;
                    dragType = 'tail';
                    isDragging = true;
                    return;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (dragType === 'tail') {
                dragging.x = mouseX;
                dragging.y = mouseY;
            } else if (dragType === 'head') {
                const dx = mouseX - dragging.x;
                const dy = mouseY - dragging.y;
                dragging.magnitude = Math.max(20, Math.sqrt(dx * dx + dy * dy));
                dragging.angle = Math.atan2(dy, dx);
            }
        });

        canvas.addEventListener('mouseup', () => {
            dragging = null;
            dragType = null;
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            dragging = null;
            dragType = null;
            isDragging = false;
        });

        // Start animation
        animate(performance.now());
    </script>
</body>
</html>