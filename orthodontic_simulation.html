<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Simulation - Bar with Forces</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .info {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        canvas {
            border: 2px solid #333;
            background-color: #fff;
            cursor: crosshair;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        button:hover {
            background-color: #45a049;
        }

        button:active {
            transform: translateY(1px);
        }

        button.active-mode {
            background-color: #ff9800;
        }

        button.delete-mode {
            background-color: #f44336;
        }

        button.delete-mode:hover {
            background-color: #da190b;
        }

        button.running {
            background-color: #f44336;
        }

        button.running:hover {
            background-color: #da190b;
        }

        .instructions {
            max-width: 800px;
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 5px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <h1>Physics Simulation - Bar with Forces</h1>

    <div class="info">
        <strong>Principle:</strong> A single force causes translation. Multiple forces cause both translation and rotation.
    </div>

    <canvas id="simulationCanvas" width="800" height="600"></canvas>

    <div class="controls">
        <button id="addForceBtn">Add Force</button>
        <button id="deleteForceBtn">Delete Force</button>
        <button id="startBtn">Start</button>
        <button id="resetBtn">Reset</button>
    </div>

    <div class="instructions">
        <strong>Instructions:</strong><br>
        • Click "Add Force" then click on canvas to place force vectors<br>
        • Drag arrow heads to change force direction and magnitude<br>
        • Drag arrow tails to reposition forces<br>
        • Click "Delete Force" then click on a force to remove it<br>
        • Click "Start" to begin simulation - the bar will move based on applied forces<br>
        • Click "Stop" to pause and adjust forces<br>
        • Single force = translation only; Multiple forces = translation + rotation
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const addForceBtn = document.getElementById('addForceBtn');
        const deleteForceBtn = document.getElementById('deleteForceBtn');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');

        const GRID_SIZE = 50;
        const BAR_WIDTH = 20;
        const BAR_HEIGHT = 120;

        // Bar properties
        let bar = {
            x: 400,
            y: 300,
            vx: 0,
            vy: 0,
            rotation: 0,
            angularVelocity: 0,
            mass: 10,
            momentOfInertia: (1/12) * 10 * (BAR_WIDTH * BAR_WIDTH + BAR_HEIGHT * BAR_HEIGHT)
        };

        // Forces array
        let forces = [];

        // Simulation state
        let isRunning = false;
        let dragging = null;
        let dragType = null;
        let addForceMode = false;
        let deleteForceMode = false;

        // Colors for forces
        const forceColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];

        // Reset function
        function reset() {
            bar = {
                x: 400,
                y: 300,
                vx: 0,
                vy: 0,
                rotation: 0,
                angularVelocity: 0,
                mass: 10,
                momentOfInertia: (1/12) * 10 * (BAR_WIDTH * BAR_WIDTH + BAR_HEIGHT * BAR_HEIGHT)
            };
            forces = [];
            isRunning = false;
            addForceMode = false;
            deleteForceMode = false;
            addForceBtn.style.backgroundColor = '#4CAF50';
            deleteForceBtn.style.backgroundColor = '#4CAF50';
            startBtn.textContent = 'Start';
            startBtn.classList.remove('running');
        }

        resetBtn.addEventListener('click', reset);

        addForceBtn.addEventListener('click', () => {
            if (isRunning) return;
            addForceMode = !addForceMode;
            deleteForceMode = false;
            addForceBtn.style.backgroundColor = addForceMode ? '#ff9800' : '#4CAF50';
            deleteForceBtn.style.backgroundColor = '#4CAF50';
            canvas.style.cursor = addForceMode ? 'crosshair' : 'default';
        });

        deleteForceBtn.addEventListener('click', () => {
            if (isRunning) return;
            deleteForceMode = !deleteForceMode;
            addForceMode = false;
            deleteForceBtn.style.backgroundColor = deleteForceMode ? '#f44336' : '#4CAF50';
            addForceBtn.style.backgroundColor = '#4CAF50';
            canvas.style.cursor = deleteForceMode ? 'pointer' : 'default';
        });

        startBtn.addEventListener('click', () => {
            isRunning = !isRunning;
            startBtn.textContent = isRunning ? 'Stop' : 'Start';
            if (isRunning) {
                startBtn.classList.add('running');
                addForceMode = false;
                deleteForceMode = false;
                addForceBtn.style.backgroundColor = '#4CAF50';
                deleteForceBtn.style.backgroundColor = '#4CAF50';
                canvas.style.cursor = 'default';
            } else {
                startBtn.classList.remove('running');
            }
        });

        // Draw grid
        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Draw bar
        function drawBar() {
            ctx.save();
            ctx.translate(bar.x, bar.y);
            ctx.rotate(bar.rotation);

            // Bar body (vertical rectangle)
            ctx.fillStyle = '#3498db';
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.fillRect(-BAR_WIDTH/2, -BAR_HEIGHT/2, BAR_WIDTH, BAR_HEIGHT);
            ctx.strokeRect(-BAR_WIDTH/2, -BAR_HEIGHT/2, BAR_WIDTH, BAR_HEIGHT);

            // Reference mark at top
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(0, -BAR_HEIGHT/2 + 10, 4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // Draw center of mass
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(bar.x, bar.y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.fillText('CM', bar.x + 8, bar.y - 8);
        }

        // Draw arrow
        function drawArrow(force, color, index) {
            const endX = force.x + Math.cos(force.angle) * force.magnitude;
            const endY = force.y + Math.sin(force.angle) * force.magnitude;

            // Arrow shaft
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(force.x, force.y);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Arrow head
            const headLength = 15;
            const headAngle = Math.PI / 6;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headLength * Math.cos(force.angle - headAngle),
                endY - headLength * Math.sin(force.angle - headAngle)
            );
            ctx.lineTo(
                endX - headLength * Math.cos(force.angle + headAngle),
                endY - headLength * Math.sin(force.angle + headAngle)
            );
            ctx.closePath();
            ctx.fill();

            // Draw tail point
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(force.x, force.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Label
            ctx.fillStyle = color;
            ctx.font = 'bold 12px Arial';
            ctx.fillText(`F${index + 1}`, force.x - 20, force.y - 10);
        }

        // Draw moment arm
        function drawMomentArm(force, color) {
            const forceEndX = force.x + Math.cos(force.angle) * 1000;
            const forceEndY = force.y + Math.sin(force.angle) * 1000;

            const dx = forceEndX - force.x;
            const dy = forceEndY - force.y;
            const t = ((bar.x - force.x) * dx + (bar.y - force.y) * dy) / (dx * dx + dy * dy);
            const closestX = force.x + t * dx;
            const closestY = force.y + t * dy;

            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(bar.x, bar.y);
            ctx.lineTo(closestX, closestY);
            ctx.stroke();
            ctx.setLineDash([]);

            const distance = Math.sqrt((bar.x - closestX) ** 2 + (bar.y - closestY) ** 2);
            return distance;
        }

        // Calculate net force and torque
        function calculatePhysics() {
            let netForceX = 0;
            let netForceY = 0;
            let netTorque = 0;

            forces.forEach(force => {
                const fx = Math.cos(force.angle) * force.magnitude;
                const fy = Math.sin(force.angle) * force.magnitude;

                netForceX += fx;
                netForceY += fy;

                // Torque = r × F (cross product)
                const rx = force.x - bar.x;
                const ry = force.y - bar.y;
                const torque = rx * fy - ry * fx;
                netTorque += torque;
            });

            return { netForceX, netForceY, netTorque };
        }

        // Update physics
        function updatePhysics(dt) {
            if (isRunning && forces.length > 0) {
                const { netForceX, netForceY, netTorque } = calculatePhysics();

                // Linear acceleration
                const ax = netForceX / bar.mass;
                const ay = netForceY / bar.mass;

                // Update velocity
                bar.vx += ax * dt * 0.1;
                bar.vy += ay * dt * 0.1;

                // Update position
                bar.x += bar.vx * dt;
                bar.y += bar.vy * dt;

                // Angular acceleration
                const angularAccel = netTorque / bar.momentOfInertia;
                bar.angularVelocity += angularAccel * dt * 0.00005;

                // Update rotation
                bar.rotation += bar.angularVelocity * dt;

                // Boundary check with bounce
                const maxDimension = Math.max(BAR_WIDTH, BAR_HEIGHT);
                if (bar.x < maxDimension) {
                    bar.x = maxDimension;
                    bar.vx *= -0.3;
                }
                if (bar.x > canvas.width - maxDimension) {
                    bar.x = canvas.width - maxDimension;
                    bar.vx *= -0.3;
                }
                if (bar.y < maxDimension) {
                    bar.y = maxDimension;
                    bar.vy *= -0.3;
                }
                if (bar.y > canvas.height - maxDimension) {
                    bar.y = canvas.height - maxDimension;
                    bar.vy *= -0.3;
                }
            } else if (!isRunning) {
                // Apply damping when stopped
                bar.vx *= 0.95;
                bar.vy *= 0.95;
                bar.angularVelocity *= 0.95;

                if (Math.abs(bar.vx) < 0.01) bar.vx = 0;
                if (Math.abs(bar.vy) < 0.01) bar.vy = 0;
                if (Math.abs(bar.angularVelocity) < 0.01) bar.angularVelocity = 0;
            }
        }

        // Update and render
        let lastTime = performance.now();
        function animate(currentTime) {
            const dt = currentTime - lastTime;
            lastTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            drawGrid();

            // Update physics
            updatePhysics(dt);

            // Draw moment arms
            forces.forEach((force, i) => {
                const color = forceColors[i % forceColors.length];
                drawMomentArm(force, color);
            });

            // Draw forces
            forces.forEach((force, i) => {
                const color = forceColors[i % forceColors.length];
                drawArrow(force, color, i);
            });

            // Draw bar
            drawBar();

            // Display info
            const { netForceX, netForceY, netTorque } = calculatePhysics();
            ctx.fillStyle = 'black';
            ctx.font = '14px Arial';
            ctx.fillText(`Forces: ${forces.length}`, 10, 20);
            ctx.fillText(`Net Force: (${netForceX.toFixed(1)}, ${netForceY.toFixed(1)})`, 10, 40);
            ctx.fillText(`Net Torque: ${netTorque.toFixed(1)}`, 10, 60);
            ctx.fillText(`Position: (${bar.x.toFixed(0)}, ${bar.y.toFixed(0)})`, 10, 80);
            ctx.fillText(`Rotation: ${(bar.rotation * 180 / Math.PI).toFixed(1)}°`, 10, 100);
            ctx.fillText(`Status: ${isRunning ? 'RUNNING' : 'STOPPED'}`, 10, 120);

            requestAnimationFrame(animate);
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            if (isRunning) return; // No interaction while running

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (addForceMode) {
                forces.push({
                    x: mouseX,
                    y: mouseY,
                    magnitude: 60,
                    angle: 0
                });
                addForceMode = false;
                addForceBtn.style.backgroundColor = '#4CAF50';
                canvas.style.cursor = 'default';
                return;
            }

            if (deleteForceMode) {
                for (let i = forces.length - 1; i >= 0; i--) {
                    const force = forces[i];
                    const endX = force.x + Math.cos(force.angle) * force.magnitude;
                    const endY = force.y + Math.sin(force.angle) * force.magnitude;

                    const distToHead = Math.sqrt((mouseX - endX) ** 2 + (mouseY - endY) ** 2);
                    const distToTail = Math.sqrt((mouseX - force.x) ** 2 + (mouseY - force.y) ** 2);

                    if (distToHead < 15 || distToTail < 10) {
                        forces.splice(i, 1);
                        break;
                    }
                }
                deleteForceMode = false;
                deleteForceBtn.style.backgroundColor = '#4CAF50';
                canvas.style.cursor = 'default';
                return;
            }

            // Check for dragging forces
            for (let i = forces.length - 1; i >= 0; i--) {
                const force = forces[i];
                const endX = force.x + Math.cos(force.angle) * force.magnitude;
                const endY = force.y + Math.sin(force.angle) * force.magnitude;

                if (Math.sqrt((mouseX - endX) ** 2 + (mouseY - endY) ** 2) < 15) {
                    dragging = force;
                    dragType = 'head';
                    canvas.style.cursor = 'move';
                    return;
                }

                if (Math.sqrt((mouseX - force.x) ** 2 + (mouseY - force.y) ** 2) < 10) {
                    dragging = force;
                    dragType = 'tail';
                    canvas.style.cursor = 'move';
                    return;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isRunning || !dragging) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (dragType === 'tail') {
                dragging.x = mouseX;
                dragging.y = mouseY;
            } else if (dragType === 'head') {
                const dx = mouseX - dragging.x;
                const dy = mouseY - dragging.y;
                dragging.magnitude = Math.max(20, Math.sqrt(dx * dx + dy * dy));
                dragging.angle = Math.atan2(dy, dx);
            }
        });

        canvas.addEventListener('mouseup', () => {
            dragging = null;
            dragType = null;
            if (!addForceMode && !deleteForceMode) {
                canvas.style.cursor = 'default';
            }
        });

        canvas.addEventListener('mouseleave', () => {
            dragging = null;
            dragType = null;
        });

        // Start animation
        animate(performance.now());
    </script>
</body>
</html>