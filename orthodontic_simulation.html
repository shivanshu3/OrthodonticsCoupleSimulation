<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Simulation - Bar with Forces</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
            margin: 0;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .info {
            margin-bottom: 20px;
            padding: 10px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .main-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .sidebar {
            width: 300px;
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 800px;
            overflow-y: auto;
        }

        .sidebar h3 {
            margin-top: 0;
            color: #333;
        }

        .force-item {
            padding: 10px;
            margin-bottom: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .force-item h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }

        .force-control {
            margin-bottom: 8px;
        }

        .force-control label {
            display: block;
            font-size: 12px;
            margin-bottom: 3px;
            color: #555;
        }

        .force-control input[type="number"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box;
        }

        canvas {
            border: 2px solid #333;
            background-color: #fff;
            cursor: crosshair;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        button:hover {
            background-color: #45a049;
        }

        button:active {
            transform: translateY(1px);
        }

        button.active-mode {
            background-color: #ff9800;
        }

        button.delete-mode {
            background-color: #f44336;
        }

        button.delete-mode:hover {
            background-color: #da190b;
        }

        button.running {
            background-color: #f44336;
        }

        button.running:hover {
            background-color: #da190b;
        }

        .instructions {
            max-width: 800px;
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 5px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <h1>Physics Simulation - Bar with Forces</h1>

    <div class="info">
        <strong>Principle:</strong> A single force causes translation. Multiple forces cause both translation and rotation.
    </div>

    <div class="main-container">
        <div class="sidebar">
            <h3>Force Vectors</h3>
            <div id="forcesList"></div>
        </div>

        <div>
            <canvas id="simulationCanvas" width="1400" height="800"></canvas>
            <div class="controls">
                <button id="addForceBtn">Add Force</button>
                <button id="deleteForceBtn">Delete Force</button>
                <button id="startBtn">Start</button>
                <button id="resetBtn">Reset</button>
            </div>
        </div>
    </div>

    <div class="instructions">
        <strong>Instructions:</strong><br>
        • Click "Add Force" then click on canvas to place force vectors<br>
        • Drag arrow heads to change force direction and magnitude<br>
        • Drag arrow tails to reposition forces<br>
        • Click "Delete Force" then click on a force to remove it<br>
        • Click "Start" to begin simulation - the bar will move based on applied forces<br>
        • Click "Stop" to pause and adjust forces<br>
        • Single force = translation only; Multiple forces = translation + rotation
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const addForceBtn = document.getElementById('addForceBtn');
        const deleteForceBtn = document.getElementById('deleteForceBtn');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const forcesList = document.getElementById('forcesList');

        const GRID_SIZE = 50;
        const BAR_WIDTH = 20;
        const BAR_HEIGHT = 120;

        // Bar properties
        let bar = {
            x: 700,
            y: 400,
            vx: 0,
            vy: 0,
            rotation: 0,
            angularVelocity: 0,
            mass: 10,
            momentOfInertia: (1/12) * 10 * (BAR_WIDTH * BAR_WIDTH + BAR_HEIGHT * BAR_HEIGHT)
        };

        // Forces array - now stored in bar-relative coordinates
        let forces = [];

        // Helper functions for coordinate conversion
        function worldToBar(worldX, worldY) {
            // Convert world coordinates to bar-relative coordinates
            const dx = worldX - bar.x;
            const dy = worldY - bar.y;
            const cos = Math.cos(-bar.rotation);
            const sin = Math.sin(-bar.rotation);
            return {
                localX: dx * cos - dy * sin,
                localY: dx * sin + dy * cos
            };
        }

        function barToWorld(localX, localY) {
            // Convert bar-relative coordinates to world coordinates
            const cos = Math.cos(bar.rotation);
            const sin = Math.sin(bar.rotation);
            return {
                worldX: bar.x + localX * cos - localY * sin,
                worldY: bar.y + localX * sin + localY * cos
            };
        }

        // Simulation state
        let isRunning = false;
        let dragging = null;
        let dragType = null;
        let addForceMode = false;
        let deleteForceMode = false;

        // Colors for forces
        const forceColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];

        // Update force list UI
        function updateForcesList() {
            forcesList.innerHTML = '';

            if (forces.length === 0) {
                forcesList.innerHTML = '<p style="color: #999; font-size: 12px;">No forces added yet</p>';
                return;
            }

            forces.forEach((force, index) => {
                const color = forceColors[index % forceColors.length];
                const angleInDegrees = (force.localAngle * 180 / Math.PI).toFixed(1);

                const forceItem = document.createElement('div');
                forceItem.className = 'force-item';
                forceItem.style.borderColor = color;

                forceItem.innerHTML = `
                    <h4 style="color: ${color}">Force ${index + 1}</h4>
                    <div class="force-control">
                        <label>Magnitude:</label>
                        <input type="number" id="magnitude-${index}" value="${force.magnitude.toFixed(1)}" step="5" min="0" ${isRunning ? 'disabled' : ''}>
                    </div>
                    <div class="force-control">
                        <label>Angle (degrees, relative to bar):</label>
                        <input type="number" id="angle-${index}" value="${angleInDegrees}" step="5" ${isRunning ? 'disabled' : ''}>
                    </div>
                `;

                forcesList.appendChild(forceItem);

                // Add event listeners
                if (!isRunning) {
                    const magnitudeInput = document.getElementById(`magnitude-${index}`);
                    const angleInput = document.getElementById(`angle-${index}`);

                    magnitudeInput.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        if (!isNaN(value) && value >= 0) {
                            force.magnitude = value;
                        }
                    });

                    angleInput.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        if (!isNaN(value)) {
                            force.localAngle = value * Math.PI / 180;
                        }
                    });
                }
            });
        }

        // Reset function
        function reset() {
            bar = {
                x: 700,
                y: 400,
                vx: 0,
                vy: 0,
                rotation: 0,
                angularVelocity: 0,
                mass: 10,
                momentOfInertia: (1/12) * 10 * (BAR_WIDTH * BAR_WIDTH + BAR_HEIGHT * BAR_HEIGHT)
            };
            forces = [];
            isRunning = false;
            addForceMode = false;
            deleteForceMode = false;
            addForceBtn.style.backgroundColor = '#4CAF50';
            deleteForceBtn.style.backgroundColor = '#4CAF50';
            startBtn.textContent = 'Start';
            startBtn.classList.remove('running');
            updateForcesList();
        }

        resetBtn.addEventListener('click', reset);

        addForceBtn.addEventListener('click', () => {
            if (isRunning) return;
            addForceMode = !addForceMode;
            deleteForceMode = false;
            addForceBtn.style.backgroundColor = addForceMode ? '#ff9800' : '#4CAF50';
            deleteForceBtn.style.backgroundColor = '#4CAF50';
            canvas.style.cursor = addForceMode ? 'crosshair' : 'default';
        });

        deleteForceBtn.addEventListener('click', () => {
            if (isRunning) return;
            deleteForceMode = !deleteForceMode;
            addForceMode = false;
            deleteForceBtn.style.backgroundColor = deleteForceMode ? '#f44336' : '#4CAF50';
            addForceBtn.style.backgroundColor = '#4CAF50';
            canvas.style.cursor = deleteForceMode ? 'pointer' : 'default';
        });

        startBtn.addEventListener('click', () => {
            isRunning = !isRunning;
            startBtn.textContent = isRunning ? 'Stop' : 'Start';
            if (isRunning) {
                startBtn.classList.add('running');
                addForceMode = false;
                deleteForceMode = false;
                addForceBtn.style.backgroundColor = '#4CAF50';
                deleteForceBtn.style.backgroundColor = '#4CAF50';
                canvas.style.cursor = 'default';
            } else {
                startBtn.classList.remove('running');
            }
            updateForcesList();
        });

        // Draw grid
        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Draw bar
        function drawBar() {
            ctx.save();
            ctx.translate(bar.x, bar.y);
            ctx.rotate(bar.rotation);

            // Bar body (vertical rectangle)
            ctx.fillStyle = '#3498db';
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.fillRect(-BAR_WIDTH/2, -BAR_HEIGHT/2, BAR_WIDTH, BAR_HEIGHT);
            ctx.strokeRect(-BAR_WIDTH/2, -BAR_HEIGHT/2, BAR_WIDTH, BAR_HEIGHT);

            // Reference mark at top
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(0, -BAR_HEIGHT/2 + 10, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();

            // Draw center of mass
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(bar.x, bar.y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.fillText('CM', bar.x + 8, bar.y - 8);
        }

        // Draw arrow
        function drawArrow(force, color, index) {
            // Convert local coordinates to world coordinates
            const worldPos = barToWorld(force.localX, force.localY);
            const worldAngle = force.localAngle + bar.rotation;

            const startX = worldPos.worldX;
            const startY = worldPos.worldY;
            const endX = startX + Math.cos(worldAngle) * force.magnitude;
            const endY = startY + Math.sin(worldAngle) * force.magnitude;

            // Arrow shaft
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Arrow head
            const headLength = 15;
            const headAngle = Math.PI / 6;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headLength * Math.cos(worldAngle - headAngle),
                endY - headLength * Math.sin(worldAngle - headAngle)
            );
            ctx.lineTo(
                endX - headLength * Math.cos(worldAngle + headAngle),
                endY - headLength * Math.sin(worldAngle + headAngle)
            );
            ctx.closePath();
            ctx.fill();

            // Draw tail point
            ctx.fillStyle = color;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(startX, startY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Label
            ctx.fillStyle = color;
            ctx.font = 'bold 12px Arial';
            ctx.fillText(`F${index + 1}`, startX - 20, startY - 10);
        }

        // Draw moment arm
        function drawMomentArm(force, color) {
            const worldPos = barToWorld(force.localX, force.localY);
            const worldAngle = force.localAngle + bar.rotation;

            const forceX = worldPos.worldX;
            const forceY = worldPos.worldY;
            const forceEndX = forceX + Math.cos(worldAngle) * 1000;
            const forceEndY = forceY + Math.sin(worldAngle) * 1000;

            const dx = forceEndX - forceX;
            const dy = forceEndY - forceY;
            const t = ((bar.x - forceX) * dx + (bar.y - forceY) * dy) / (dx * dx + dy * dy);
            const closestX = forceX + t * dx;
            const closestY = forceY + t * dy;

            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(bar.x, bar.y);
            ctx.lineTo(closestX, closestY);
            ctx.stroke();
            ctx.setLineDash([]);

            const distance = Math.sqrt((bar.x - closestX) ** 2 + (bar.y - closestY) ** 2);
            return distance;
        }

        // Calculate net force and torque
        function calculatePhysics() {
            let netForceX = 0;
            let netForceY = 0;
            let netTorque = 0;

            forces.forEach(force => {
                const worldPos = barToWorld(force.localX, force.localY);
                const worldAngle = force.localAngle + bar.rotation;

                const fx = Math.cos(worldAngle) * force.magnitude;
                const fy = Math.sin(worldAngle) * force.magnitude;

                netForceX += fx;
                netForceY += fy;

                // Torque = r × F (cross product)
                const rx = worldPos.worldX - bar.x;
                const ry = worldPos.worldY - bar.y;
                const torque = rx * fy - ry * fx;
                netTorque += torque;
            });

            return { netForceX, netForceY, netTorque };
        }

        // Update physics
        function updatePhysics(dt) {
            if (isRunning && forces.length > 0) {
                const { netForceX, netForceY, netTorque } = calculatePhysics();

                // Linear acceleration
                const ax = netForceX / bar.mass;
                const ay = netForceY / bar.mass;

                // Update velocity (slowed down 200x total)
                bar.vx += ax * dt * 0.0005;
                bar.vy += ay * dt * 0.0005;

                // Update position
                bar.x += bar.vx * dt;
                bar.y += bar.vy * dt;

                // Angular acceleration (slowed down 200x total)
                const angularAccel = netTorque / bar.momentOfInertia;
                bar.angularVelocity += angularAccel * dt * 0.00000025;

                // Update rotation
                bar.rotation += bar.angularVelocity * dt;

                // Boundary check with bounce
                const maxDimension = Math.max(BAR_WIDTH, BAR_HEIGHT);
                if (bar.x < maxDimension) {
                    bar.x = maxDimension;
                    bar.vx *= -0.3;
                }
                if (bar.x > canvas.width - maxDimension) {
                    bar.x = canvas.width - maxDimension;
                    bar.vx *= -0.3;
                }
                if (bar.y < maxDimension) {
                    bar.y = maxDimension;
                    bar.vy *= -0.3;
                }
                if (bar.y > canvas.height - maxDimension) {
                    bar.y = canvas.height - maxDimension;
                    bar.vy *= -0.3;
                }
            } else if (!isRunning) {
                // Apply damping when stopped
                bar.vx *= 0.95;
                bar.vy *= 0.95;
                bar.angularVelocity *= 0.95;

                if (Math.abs(bar.vx) < 0.01) bar.vx = 0;
                if (Math.abs(bar.vy) < 0.01) bar.vy = 0;
                if (Math.abs(bar.angularVelocity) < 0.01) bar.angularVelocity = 0;
            }
        }

        // Update and render
        let lastTime = performance.now();
        function animate(currentTime) {
            const dt = currentTime - lastTime;
            lastTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            drawGrid();

            // Update physics
            updatePhysics(dt);

            // Draw moment arms
            forces.forEach((force, i) => {
                const color = forceColors[i % forceColors.length];
                drawMomentArm(force, color);
            });

            // Draw forces
            forces.forEach((force, i) => {
                const color = forceColors[i % forceColors.length];
                drawArrow(force, color, i);
            });

            // Draw bar
            drawBar();

            // Display info
            const { netForceX, netForceY, netTorque } = calculatePhysics();
            ctx.fillStyle = 'black';
            ctx.font = '14px Arial';
            ctx.fillText(`Forces: ${forces.length}`, 10, 20);
            ctx.fillText(`Net Force: (${netForceX.toFixed(1)}, ${netForceY.toFixed(1)})`, 10, 40);
            ctx.fillText(`Net Torque: ${netTorque.toFixed(1)}`, 10, 60);
            ctx.fillText(`Position: (${bar.x.toFixed(0)}, ${bar.y.toFixed(0)})`, 10, 80);
            ctx.fillText(`Rotation: ${(bar.rotation * 180 / Math.PI).toFixed(1)}°`, 10, 100);
            ctx.fillText(`Status: ${isRunning ? 'RUNNING' : 'STOPPED'}`, 10, 120);

            requestAnimationFrame(animate);
        }

        // Mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            if (isRunning) return; // No interaction while running

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (addForceMode) {
                // Convert world coordinates to bar-local coordinates
                const local = worldToBar(mouseX, mouseY);
                forces.push({
                    localX: local.localX,
                    localY: local.localY,
                    magnitude: 60,
                    localAngle: 0 // Angle relative to bar orientation
                });
                addForceMode = false;
                addForceBtn.style.backgroundColor = '#4CAF50';
                canvas.style.cursor = 'default';
                updateForcesList();
                return;
            }

            if (deleteForceMode) {
                for (let i = forces.length - 1; i >= 0; i--) {
                    const force = forces[i];
                    const worldPos = barToWorld(force.localX, force.localY);
                    const worldAngle = force.localAngle + bar.rotation;

                    const startX = worldPos.worldX;
                    const startY = worldPos.worldY;
                    const endX = startX + Math.cos(worldAngle) * force.magnitude;
                    const endY = startY + Math.sin(worldAngle) * force.magnitude;

                    const distToHead = Math.sqrt((mouseX - endX) ** 2 + (mouseY - endY) ** 2);
                    const distToTail = Math.sqrt((mouseX - startX) ** 2 + (mouseY - startY) ** 2);

                    if (distToHead < 15 || distToTail < 10) {
                        forces.splice(i, 1);
                        break;
                    }
                }
                deleteForceMode = false;
                deleteForceBtn.style.backgroundColor = '#4CAF50';
                canvas.style.cursor = 'default';
                updateForcesList();
                return;
            }

            // Check for dragging forces
            for (let i = forces.length - 1; i >= 0; i--) {
                const force = forces[i];
                const worldPos = barToWorld(force.localX, force.localY);
                const worldAngle = force.localAngle + bar.rotation;

                const startX = worldPos.worldX;
                const startY = worldPos.worldY;
                const endX = startX + Math.cos(worldAngle) * force.magnitude;
                const endY = startY + Math.sin(worldAngle) * force.magnitude;

                if (Math.sqrt((mouseX - endX) ** 2 + (mouseY - endY) ** 2) < 15) {
                    dragging = force;
                    dragType = 'head';
                    canvas.style.cursor = 'move';
                    return;
                }

                if (Math.sqrt((mouseX - startX) ** 2 + (mouseY - startY) ** 2) < 10) {
                    dragging = force;
                    dragType = 'tail';
                    canvas.style.cursor = 'move';
                    return;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isRunning || !dragging) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (dragType === 'tail') {
                // Update the local position of the force
                const local = worldToBar(mouseX, mouseY);
                dragging.localX = local.localX;
                dragging.localY = local.localY;
            } else if (dragType === 'head') {
                // Update magnitude and angle in local coordinates
                const worldPos = barToWorld(dragging.localX, dragging.localY);
                const dx = mouseX - worldPos.worldX;
                const dy = mouseY - worldPos.worldY;
                dragging.magnitude = Math.max(20, Math.sqrt(dx * dx + dy * dy));

                // Calculate world angle, then convert to local angle
                const worldAngle = Math.atan2(dy, dx);
                dragging.localAngle = worldAngle - bar.rotation;
            }
        });

        canvas.addEventListener('mouseup', () => {
            dragging = null;
            dragType = null;
            if (!addForceMode && !deleteForceMode) {
                canvas.style.cursor = 'default';
            }
        });

        canvas.addEventListener('mouseleave', () => {
            dragging = null;
            dragType = null;
        });

        // Initialize UI
        updateForcesList();

        // Start animation
        animate(performance.now());
    </script>
</body>
</html>